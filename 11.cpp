// This time instead of using the two arrays to find out which frequencies it is
// I'm gonna use the letter to search for the frequency THEN use the frequency to print out
// the binary code OR just add the string binary code for each letter lmao

//*******************************************************
//
// An T. Vo
// CS 302 - 1002, November 6th 2018
// Assignment #6
//
//*******************************************************

/* Write a C++ program which uses Huffman's algorithm to create an optimum prefix-free code for the
 * the Roman alphabet, together with ta symbol for space, using the frequencies of letters used in
 * English. Since I want everyone's code to be the same, you must use the list of
 * frequencies given in the file.
 */


/* Write a C++ program which encodes a file of paintext into a string of bits, using that Huffman code.
*/

/* Write a C++ program which decodes a string of bit sinto plaintext.
*/

/* 1. The program should first create the code, 
   2. then prompt the user to either encode or decode
   3. In either case, the user enters the name of the file (plaintext or code) to read,
   and the name of the file to write
   4. You could, instead, write the Huffman code into a file, then read that file to either encode or decode. 
   Dr. Larmore does not recommend this.
*/

// Writing encoding

// Use your program to encode text files and to decode files consisting of zeros and ones



#include <iostream>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <iomanip>
//************************
// checking if there is a memory leak
#define _CRTDBG_MAP_ALLOC  
#include <stdlib.h>  
#include <crtdbg.h>  
//************************

using namespace std;

const int ORIGINAL_NUMBER_OF_NODES = 27; // because there should be only 26 nodes to carry each letter from the alphabet
										 // and one node to hold "space"

//*************************************************************************
// struct HuffNode is the binary tree structure to be used for the
// Huffman algorithm
struct HuffNode
{
	int frequency;
	char letter;
	string binaryCode;

	HuffNode *left, *right;

	HuffNode(int frequency, char letter, string binaryCode)
	{
		left = NULL;
		right = NULL;
		this->frequency = frequency;
		this->letter = letter;
		this->binaryCode = binaryCode;
	}
};

// struct compare is used as the condition to be implmented upon
// the priority_queue because a priority queue is best data structure
// to store the small binary trees, which hold data, then merge them
// together
// Condition: left-frequency must be larger than right->frequency
// => the smallest binary tree has the highest priority
// in template <class T, class Container = vector<T>>
struct compare 
{
	bool operator()(HuffNode *left, HuffNode *right)
	{
		return (left->frequency > right->frequency);
	}
};

// print binary code generated by Huffman algorithm
// void function printBinaryData prints each letter and binary code
// that is associated with the letter to verify if Huffman algorithm works
void printBinaryData(struct HuffNode* root, string str)
{
	if (!root) 			// if the root is empty, terminate the void funtion
		return;

	printBinaryData(root->left, str + "0");   
	printBinaryData(root->right, str + "1");
	if (root->letter != '%')
		cout << root->letter << ": " << str << "\n";
}

// print the frequency
// void function printFrequency prints each letter and its frequency
// to verify if the program reads the data well
void printFrequency(struct HuffNode* root)
{
	if (!root) 			// if the root is empty, terminate the void funtion
		return;	
	
	if (root->letter != '%')
		cout << root->letter << ": " << root->frequency << "\n";
	printFrequency(root->left);
	printFrequency(root->right);

}

// Returns true if and only if the tree contains the node with the
// letter 'letter'
bool contains(struct HuffNode* root, char letter)
{
	if(root == NULL)
		return false;
	if(letter == root->letter)
		return true;
	if(contains(root->left, letter))
		return true;
	if(contains(root->right, letter))
		return true;

	return false;
}


// the construction of a Huffman Tree
// void function HuffmanConstruction will generate the Huffman binary tree using
// a simple mersort and a priority queue that stores small binary trees.
// While the queue size is still not 0, it will pop the first 2 highest nodes
// of the queues (2 nodes with the smallest frequencies), then merge them into one,
// then push it into the queue. The previous step will continue until all of the binary
// trees become one.
// Precondition: integer array frequencies and character array letters, which are the input data
//				 int size as the size of both data, and the struct HuffNode completeHuffmanTree
// 				 takes the top element of the queue as the main binary tree used for encoding
// 				 and decoding
void HuffmanConstruction(int frequencies[], char letters[], int size, struct HuffNode* &completeHuffmanTree)
{
	struct HuffNode *left, *right, *top;								// create 3 pointers to point at right hand sided trees

	priority_queue<HuffNode*, vector<HuffNode*>, compare> HuffmanQueue;	// creating a priority queue of trees where the smallest node has the highest priority
																		// with the syntax of template <class T, class Container = vector<T>, law>

	for (int i = 0; i < size; ++i)
	{
		HuffmanQueue.push(new HuffNode(frequencies[i], letters[i], "")); // insert items into the tree then push the tree into the queue
	}


	// if the size of the queue is still larger than 1, then merge small trees together
	// to complete a tree generated by Huffman algorithm
	while (HuffmanQueue.size() != 1)
	{
		left = HuffmanQueue.top();
		HuffmanQueue.pop();

		right = HuffmanQueue.top();
		HuffmanQueue.pop();

		top = new HuffNode(left->frequency + right->frequency, '%', "");

		top->left = left;
		top->right = right;

		HuffmanQueue.push(top);
	}

	//printBinaryData(HuffmanQueue.top(), "");
	//printFrequency(HuffmanQueue.top());
	completeHuffmanTree = HuffmanQueue.top();
}

// Free (deallocate) the memory allocated for the Huffman tree 'root' (or more
// specifically, the Huffman tree whose root is 'root').
void free_memory(struct HuffNode* root)
{
	if (root == NULL)
		return;
	free_memory(root->left);
	free_memory(root->right);

	delete root;
}

//******************************************************************************************
void createTheCode(struct HuffNode*&, int[]);
// void function createTheNode will read the file of frequencies then construct
// the binary tree generated by Huffman algorithm

void encodingPart(struct HuffNode*);
string encoding(struct HuffNode*,char);
void test(struct HuffNode*,char);
/* 1. The program should first create the code, 
   2. then prompt the user to either encode or decode
   3. In either case, the user enters the name of the file (plaintext or code) to read,
   and the name of the file to write
   4. You could, instead, write the Huffman code into a file, then read that file to either encode or decode. 
   Dr. Larmore does not recommend this.
*/

int main() 
{ 
	// 1.
    struct HuffNode *completeHuffmanTree = NULL;
    int frequencies[ORIGINAL_NUMBER_OF_NODES];
    for (int i = 0; i < ORIGINAL_NUMBER_OF_NODES; ++i)
    {
    	frequencies[i] = 0;
    }

    createTheCode(completeHuffmanTree, frequencies);
 
 	// 2.
    int choice = 0;
    string prompt1 = "Would you like to encode or decode?\nPlease:\nPress 1 to encode\nPress 2 to decode\n";    
    string prompt2 = "Press 9 to exit\n"; 
    cout << prompt1 << prompt2;
    cin >> choice;
    while(cin)
    {
	    if (choice == 1)
	    {
	    	encodingPart(completeHuffmanTree);
	    	break;
	    }
	    else if (choice == 2)
	    	break;
	    	// decode
	    else if (choice == 9)
	    	break;
	    else
	    {
	    	cout << "Invalid choice. Please choose again" << endl;    
	    	cin >> choice;	
	    }
    }
    //*************

	free_memory(completeHuffmanTree);

	_CrtDumpMemoryLeaks();  
	system("pause");
    return 0; 
} 

//****************************************************************************************** larmore
























































void encodingPart(struct HuffNode* HuffmanTree)
{
	// declaring variables
	string inputfile;
	string outputfile;
	ifstream infile;
	ofstream outfile;

	// int countForPrintingEndline = 1;

	char text;
	string str = "";
	char endOfLine = ' ';

	cout << "\n\nPlease enter the name of the file (plaintext or code)"
		 << " to read:" << endl;
	cin >> inputfile;
	infile.open(inputfile.c_str());
	while(infile.get(text))
	{
		str += encoding(HuffmanTree, text);
		//test(HuffmanTree, text);
		/*
		if (countForPrintingEndline == 80)
		{
			cout << endl;
			countForPrintingEndline = 1;
		}
		countForPrintingEndline++;
		*/
	//	cout << text;
	}
	// GENERATE a SPACE in the END OF LINE
	str+= encoding(HuffmanTree, endOfLine);

	for (int i = 0; i < static_cast<int>(str.size()) ; ++i)
	{
		if (i % 80 == 0 && i != 0)
			cout << endl;
		cout << str[i];
	}

	cout << "\n";
}

void test(struct HuffNode* root, char letter)
{
	/*
	 * 1. toupper the letter
	 * 2. find the letter
	 * 3. print the binary data
	 */
	if (letter >= 97 && letter <= 122)
		letter = letter - 32;
	if (letter < 65 || letter > 90)
		letter = 32;
	 cout << letter; 
}


string encoding(struct HuffNode* root, char letter)
{
	/*
	 * 1. toupper the letter
	 * 2. find the letter
	 * 3. print the binary data
	 */
	// int countForPrintingEndline
	if (letter >= 97 && letter <= 122)
		letter = letter - 32;
	if (letter < 65 || letter > 90)
		letter = 32;
	// cout << letter; 

	string encoded_str;
	HuffNode *temp = root;
	HuffNode *tempLeft = root->left;
	HuffNode *tempRight = root->right;

	if (temp == NULL)
		return encoded_str;

	if (contains(tempLeft, letter) == true)
	{
		encoded_str += "0";
		encoded_str += encoding(tempLeft, letter);
	}
	else if (contains(tempRight, letter) == true)
	{
		encoded_str += "1";
		encoded_str += encoding(tempRight, letter);
	}

	return encoded_str;
}

/*
void searchAndPrintBinary(struct HuffNode* root, string str, letter)
{
	if (!root) 			// if the root is empty, terminate the void funtion
		return;

	printBinaryData(root->left, str + "0");   
	printBinaryData(root->right, str + "1");
	if (root->letter != '%')
		cout << root->letter << ": " << str << "\n";
}
*/




























void createTheCode(struct HuffNode* &completeHuffmanTree, int frequencies[])
// void function createTheNode will read the file of frequencies then construct
// the binary tree generated by Huffman algorithm
{
	// declaring variables
	char letter[ORIGINAL_NUMBER_OF_NODES];
	for (int i = 0; i < ORIGINAL_NUMBER_OF_NODES; ++i)
	{
		letter[i] = '%';    // as in % is the initilizing value
	}
	
	int index = 0;

	// variable for the ifstream
	ifstream infile;

	// open file
	infile.open("frequencies.txt");

	// check if the file is correct
	if (!infile)
	{
		cout << "Wrong input file" << endl;
		return;
	}

	// storing inputs into arrays
	infile >> frequencies[index];
	letter[index] = ' ';
	index++;
	while(!infile.eof())
	{
		infile >> letter[index] >> frequencies[index];
		index++;
	}

//	completeHuffmanTree = HuffmanConstruction(frequencies, letter, index); 			// testing to switch void function HuffmanConstruction
																					// into a node returned function. Worked
	HuffmanConstruction(frequencies, letter, index, completeHuffmanTree);
	// printFrequency(completeHuffmanTree);

	infile.close();
}