//*******************************************************
//
// An T. Vo
// CS 302 - 1002, November 6th 2018
// Assignment #6
//
//*******************************************************

#ifndef HUFFMAN_NODE_H
#define HUFFMAN_NODE_H

#include <iostream>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <iomanip>

using namespace std;
//*************************************************************************
// struct HuffNode is the binary tree structure to be used for the
// Huffman algorithm
struct HuffNode
{
	int frequency;
	char letter;

	HuffNode *left, *right; 					// tree has left and right

	HuffNode(int frequency, char letter)		// constructor within a struct
	{
		left = NULL;
		right = NULL;
		this->frequency = frequency;
		this->letter = letter;
	}
};

// struct compare is used as the condition to be implmented upon
// the priority_queue because a priority queue is best data structure
// to store the small binary trees, which hold data, then merge them
// together
// Condition: left-frequency must be larger than right->frequency
// => the smallest binary tree has the highest priority
// in template <class T, class Container = vector<T>>
struct compare 
{
	bool operator()(HuffNode *left, HuffNode *right)
	{
		return (left->frequency > right->frequency);
	}
};

// print binary code generated by Huffman algorithm
// void function printBinaryData prints each letter and binary code
// that is associated with the letter to verify if Huffman algorithm works
void printBinaryData(struct HuffNode* root, string str)
{
	if (!root) 			// if the root is empty, terminate the void funtion
		return;

	printBinaryData(root->left, str + "0");   
	printBinaryData(root->right, str + "1");
	if (root->letter != '%')
		cout << root->letter << ": " << str << "\n";
}

// print the frequency
// void function printFrequency prints each letter and its frequency
// to verify if the program reads the data well
void printFrequency(struct HuffNode* root)
{
	if (!root) 			// if the root is empty, terminate the void funtion
		return;	
	
	if (root->letter != '%')
		cout << root->letter << ": " << root->frequency << "\n";
	printFrequency(root->left);
	printFrequency(root->right);

}

// Returns true if and only if the tree contains the node with the
// letter 'letter'
bool contains(struct HuffNode* root, char letter)
{
	if(root == NULL)
		return false;
	if(letter == root->letter)
		return true;
	if(contains(root->left, letter))
		return true;
	if(contains(root->right, letter))
		return true;

	return false;
}

// Return true if the node is a leaf
// because only a leaf holds one of the assgined letters
bool is_leaf(struct HuffNode* root)
{
	if(root == NULL)
		return true;
	if(root->left == NULL && root->right == NULL)
		return true;
	if(is_leaf(root->left))
		return true;									// Larmore
	if(is_leaf(root->right))
		return true;

	return false;
}


// the construction of a Huffman Tree
// void function HuffmanConstruction will generate the Huffman binary tree using
// a simple mersort and a priority queue that stores small binary trees.
// While the queue size is still not 0, it will pop the first 2 highest nodes
// of the queues (2 nodes with the smallest frequencies), then merge them into one,
// then push it into the queue. The previous step will continue until all of the binary
// trees become one.
// Precondition: integer array frequencies and character array letters, which are the input data
//				 int size as the size of both data, and the struct HuffNode completeHuffmanTree
// 				 takes the top element of the queue as the main binary tree used for encoding
// 				 and decoding
void HuffmanConstruction(int frequencies[], char letters[], int size, struct HuffNode* &completeHuffmanTree)
{
	struct HuffNode *left, *right, *top;								// create 3 pointers to point at right hand sided trees

	priority_queue<HuffNode*, vector<HuffNode*>, compare> HuffmanQueue;	// creating a priority queue of trees where the smallest node has the highest priority
																		// with the syntax of template <class T, class Container = vector<T>, law>

	for (int i = 0; i < size; ++i)
	{
		HuffmanQueue.push(new HuffNode(frequencies[i], letters[i])); // insert items into the tree then push the tree into the queue
	}


	// if the size of the queue is still larger than 1, then merge small trees together
	// to complete a tree generated by Huffman algorithm
	while (HuffmanQueue.size() != 1)
	{
		left = HuffmanQueue.top();
		HuffmanQueue.pop();

		right = HuffmanQueue.top();
		HuffmanQueue.pop();

		top = new HuffNode(left->frequency + right->frequency, '%');

		top->left = left;
		top->right = right;

		HuffmanQueue.push(top);
	}

	//printBinaryData(HuffmanQueue.top(), "");
	//printFrequency(HuffmanQueue.top());
	completeHuffmanTree = HuffmanQueue.top();
}

// Free (deallocate) the memory allocated for the Huffman tree 'root' (or more
// specifically, the Huffman tree whose root is 'root').
void free_memory(struct HuffNode* root)
{
	if (root == NULL)
		return;
	free_memory(root->left);
	free_memory(root->right);

	delete root;
}

#endif 